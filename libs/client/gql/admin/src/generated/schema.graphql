schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  refresh the cache entry
  """
  refresh: Boolean! = false

  """
  measured in seconds
  """
  ttl: Int! = 60
) on QUERY

type BalanceTokenData {
  address: String
  balanceUsd: Float
  decimals: Int
  name: String
  symbol: String
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
columns and relationships of "Transaction"
"""
type Transaction {
  blockHash: String!
  blockNumber: float8!
  contractAddress: String
  createdAt: timestamp!
  data: String!
  fromAddress: String!
  gasFee: float8!
  gasFeeUsd: float8!
  gasLimit: float8!
  gasPrice: float8!
  gasUsed: float8!
  id: String!
  input: String!
  nonce: Int!
  status: Boolean!
  toAddress: String!
  transaction: String!
  updatedAt: timestamp!
  value: float8!
  walletId: String
}

"""
aggregated selection of "Transaction"
"""
type Transaction_aggregate {
  aggregate: Transaction_aggregate_fields
  nodes: [Transaction!]!
}

"""
aggregate fields of "Transaction"
"""
type Transaction_aggregate_fields {
  avg: Transaction_avg_fields
  count(columns: [Transaction_select_column!], distinct: Boolean): Int!
  max: Transaction_max_fields
  min: Transaction_min_fields
  stddev: Transaction_stddev_fields
  stddev_pop: Transaction_stddev_pop_fields
  stddev_samp: Transaction_stddev_samp_fields
  sum: Transaction_sum_fields
  var_pop: Transaction_var_pop_fields
  var_samp: Transaction_var_samp_fields
  variance: Transaction_variance_fields
}

"""
aggregate avg on columns
"""
type Transaction_avg_fields {
  blockNumber: Float
  gasFee: Float
  gasFeeUsd: Float
  gasLimit: Float
  gasPrice: Float
  gasUsed: Float
  nonce: Float
  value: Float
}

"""
Boolean expression to filter rows from the table "Transaction". All fields are combined with a logical 'AND'.
"""
input Transaction_bool_exp {
  _and: [Transaction_bool_exp!]
  _not: Transaction_bool_exp
  _or: [Transaction_bool_exp!]
  blockHash: String_comparison_exp
  blockNumber: float8_comparison_exp
  contractAddress: String_comparison_exp
  createdAt: timestamp_comparison_exp
  data: String_comparison_exp
  fromAddress: String_comparison_exp
  gasFee: float8_comparison_exp
  gasFeeUsd: float8_comparison_exp
  gasLimit: float8_comparison_exp
  gasPrice: float8_comparison_exp
  gasUsed: float8_comparison_exp
  id: String_comparison_exp
  input: String_comparison_exp
  nonce: Int_comparison_exp
  status: Boolean_comparison_exp
  toAddress: String_comparison_exp
  transaction: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  value: float8_comparison_exp
  walletId: String_comparison_exp
}

"""
unique or primary key constraints on table "Transaction"
"""
enum Transaction_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Transaction_pkey
}

"""
input type for incrementing numeric columns in table "Transaction"
"""
input Transaction_inc_input {
  blockNumber: float8
  gasFee: float8
  gasFeeUsd: float8
  gasLimit: float8
  gasPrice: float8
  gasUsed: float8
  nonce: Int
  value: float8
}

"""
input type for inserting data into table "Transaction"
"""
input Transaction_insert_input {
  blockHash: String
  blockNumber: float8
  contractAddress: String
  createdAt: timestamp
  data: String
  fromAddress: String
  gasFee: float8
  gasFeeUsd: float8
  gasLimit: float8
  gasPrice: float8
  gasUsed: float8
  id: String
  input: String
  nonce: Int
  status: Boolean
  toAddress: String
  transaction: String
  updatedAt: timestamp
  value: float8
  walletId: String
}

"""
aggregate max on columns
"""
type Transaction_max_fields {
  blockHash: String
  blockNumber: float8
  contractAddress: String
  createdAt: timestamp
  data: String
  fromAddress: String
  gasFee: float8
  gasFeeUsd: float8
  gasLimit: float8
  gasPrice: float8
  gasUsed: float8
  id: String
  input: String
  nonce: Int
  toAddress: String
  transaction: String
  updatedAt: timestamp
  value: float8
  walletId: String
}

"""
aggregate min on columns
"""
type Transaction_min_fields {
  blockHash: String
  blockNumber: float8
  contractAddress: String
  createdAt: timestamp
  data: String
  fromAddress: String
  gasFee: float8
  gasFeeUsd: float8
  gasLimit: float8
  gasPrice: float8
  gasUsed: float8
  id: String
  input: String
  nonce: Int
  toAddress: String
  transaction: String
  updatedAt: timestamp
  value: float8
  walletId: String
}

"""
response of any mutation on the table "Transaction"
"""
type Transaction_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Transaction!]!
}

"""
on_conflict condition type for table "Transaction"
"""
input Transaction_on_conflict {
  constraint: Transaction_constraint!
  update_columns: [Transaction_update_column!]! = []
  where: Transaction_bool_exp
}

"""
Ordering options when selecting data from "Transaction".
"""
input Transaction_order_by {
  blockHash: order_by
  blockNumber: order_by
  contractAddress: order_by
  createdAt: order_by
  data: order_by
  fromAddress: order_by
  gasFee: order_by
  gasFeeUsd: order_by
  gasLimit: order_by
  gasPrice: order_by
  gasUsed: order_by
  id: order_by
  input: order_by
  nonce: order_by
  status: order_by
  toAddress: order_by
  transaction: order_by
  updatedAt: order_by
  value: order_by
  walletId: order_by
}

"""
primary key columns input for table: Transaction
"""
input Transaction_pk_columns_input {
  id: String!
}

"""
select columns of table "Transaction"
"""
enum Transaction_select_column {
  """
  column name
  """
  blockHash

  """
  column name
  """
  blockNumber

  """
  column name
  """
  contractAddress

  """
  column name
  """
  createdAt

  """
  column name
  """
  data

  """
  column name
  """
  fromAddress

  """
  column name
  """
  gasFee

  """
  column name
  """
  gasFeeUsd

  """
  column name
  """
  gasLimit

  """
  column name
  """
  gasPrice

  """
  column name
  """
  gasUsed

  """
  column name
  """
  id

  """
  column name
  """
  input

  """
  column name
  """
  nonce

  """
  column name
  """
  status

  """
  column name
  """
  toAddress

  """
  column name
  """
  transaction

  """
  column name
  """
  updatedAt

  """
  column name
  """
  value

  """
  column name
  """
  walletId
}

"""
input type for updating data in table "Transaction"
"""
input Transaction_set_input {
  blockHash: String
  blockNumber: float8
  contractAddress: String
  createdAt: timestamp
  data: String
  fromAddress: String
  gasFee: float8
  gasFeeUsd: float8
  gasLimit: float8
  gasPrice: float8
  gasUsed: float8
  id: String
  input: String
  nonce: Int
  status: Boolean
  toAddress: String
  transaction: String
  updatedAt: timestamp
  value: float8
  walletId: String
}

"""
aggregate stddev on columns
"""
type Transaction_stddev_fields {
  blockNumber: Float
  gasFee: Float
  gasFeeUsd: Float
  gasLimit: Float
  gasPrice: Float
  gasUsed: Float
  nonce: Float
  value: Float
}

"""
aggregate stddev_pop on columns
"""
type Transaction_stddev_pop_fields {
  blockNumber: Float
  gasFee: Float
  gasFeeUsd: Float
  gasLimit: Float
  gasPrice: Float
  gasUsed: Float
  nonce: Float
  value: Float
}

"""
aggregate stddev_samp on columns
"""
type Transaction_stddev_samp_fields {
  blockNumber: Float
  gasFee: Float
  gasFeeUsd: Float
  gasLimit: Float
  gasPrice: Float
  gasUsed: Float
  nonce: Float
  value: Float
}

"""
Streaming cursor of the table "Transaction"
"""
input Transaction_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Transaction_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Transaction_stream_cursor_value_input {
  blockHash: String
  blockNumber: float8
  contractAddress: String
  createdAt: timestamp
  data: String
  fromAddress: String
  gasFee: float8
  gasFeeUsd: float8
  gasLimit: float8
  gasPrice: float8
  gasUsed: float8
  id: String
  input: String
  nonce: Int
  status: Boolean
  toAddress: String
  transaction: String
  updatedAt: timestamp
  value: float8
  walletId: String
}

"""
aggregate sum on columns
"""
type Transaction_sum_fields {
  blockNumber: float8
  gasFee: float8
  gasFeeUsd: float8
  gasLimit: float8
  gasPrice: float8
  gasUsed: float8
  nonce: Int
  value: float8
}

"""
update columns of table "Transaction"
"""
enum Transaction_update_column {
  """
  column name
  """
  blockHash

  """
  column name
  """
  blockNumber

  """
  column name
  """
  contractAddress

  """
  column name
  """
  createdAt

  """
  column name
  """
  data

  """
  column name
  """
  fromAddress

  """
  column name
  """
  gasFee

  """
  column name
  """
  gasFeeUsd

  """
  column name
  """
  gasLimit

  """
  column name
  """
  gasPrice

  """
  column name
  """
  gasUsed

  """
  column name
  """
  id

  """
  column name
  """
  input

  """
  column name
  """
  nonce

  """
  column name
  """
  status

  """
  column name
  """
  toAddress

  """
  column name
  """
  transaction

  """
  column name
  """
  updatedAt

  """
  column name
  """
  value

  """
  column name
  """
  walletId
}

input Transaction_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: Transaction_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: Transaction_set_input
  where: Transaction_bool_exp!
}

"""
aggregate var_pop on columns
"""
type Transaction_var_pop_fields {
  blockNumber: Float
  gasFee: Float
  gasFeeUsd: Float
  gasLimit: Float
  gasPrice: Float
  gasUsed: Float
  nonce: Float
  value: Float
}

"""
aggregate var_samp on columns
"""
type Transaction_var_samp_fields {
  blockNumber: Float
  gasFee: Float
  gasFeeUsd: Float
  gasLimit: Float
  gasPrice: Float
  gasUsed: Float
  nonce: Float
  value: Float
}

"""
aggregate variance on columns
"""
type Transaction_variance_fields {
  blockNumber: Float
  gasFee: Float
  gasFeeUsd: Float
  gasLimit: Float
  gasPrice: Float
  gasUsed: Float
  nonce: Float
  value: Float
}

"""
columns and relationships of "Wallet"
"""
type Wallet {
  address: String!
  balanceUsd: float8!
  createdAt: timestamp!
  id: String!
  name: String
  network: String!
  updatedAt: timestamp!
}

"""
aggregated selection of "Wallet"
"""
type Wallet_aggregate {
  aggregate: Wallet_aggregate_fields
  nodes: [Wallet!]!
}

"""
aggregate fields of "Wallet"
"""
type Wallet_aggregate_fields {
  avg: Wallet_avg_fields
  count(columns: [Wallet_select_column!], distinct: Boolean): Int!
  max: Wallet_max_fields
  min: Wallet_min_fields
  stddev: Wallet_stddev_fields
  stddev_pop: Wallet_stddev_pop_fields
  stddev_samp: Wallet_stddev_samp_fields
  sum: Wallet_sum_fields
  var_pop: Wallet_var_pop_fields
  var_samp: Wallet_var_samp_fields
  variance: Wallet_variance_fields
}

"""
aggregate avg on columns
"""
type Wallet_avg_fields {
  balanceUsd: Float
}

"""
Boolean expression to filter rows from the table "Wallet". All fields are combined with a logical 'AND'.
"""
input Wallet_bool_exp {
  _and: [Wallet_bool_exp!]
  _not: Wallet_bool_exp
  _or: [Wallet_bool_exp!]
  address: String_comparison_exp
  balanceUsd: float8_comparison_exp
  createdAt: timestamp_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  network: String_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"""
unique or primary key constraints on table "Wallet"
"""
enum Wallet_constraint {
  """
  unique or primary key constraint on columns "network", "address"
  """
  Wallet_network_address_key

  """
  unique or primary key constraint on columns "id"
  """
  Wallet_pkey
}

"""
input type for incrementing numeric columns in table "Wallet"
"""
input Wallet_inc_input {
  balanceUsd: float8
}

"""
input type for inserting data into table "Wallet"
"""
input Wallet_insert_input {
  address: String
  balanceUsd: float8
  createdAt: timestamp
  id: String
  name: String
  network: String
  updatedAt: timestamp
}

"""
aggregate max on columns
"""
type Wallet_max_fields {
  address: String
  balanceUsd: float8
  createdAt: timestamp
  id: String
  name: String
  network: String
  updatedAt: timestamp
}

"""
aggregate min on columns
"""
type Wallet_min_fields {
  address: String
  balanceUsd: float8
  createdAt: timestamp
  id: String
  name: String
  network: String
  updatedAt: timestamp
}

"""
response of any mutation on the table "Wallet"
"""
type Wallet_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [Wallet!]!
}

"""
on_conflict condition type for table "Wallet"
"""
input Wallet_on_conflict {
  constraint: Wallet_constraint!
  update_columns: [Wallet_update_column!]! = []
  where: Wallet_bool_exp
}

"""
Ordering options when selecting data from "Wallet".
"""
input Wallet_order_by {
  address: order_by
  balanceUsd: order_by
  createdAt: order_by
  id: order_by
  name: order_by
  network: order_by
  updatedAt: order_by
}

"""
primary key columns input for table: Wallet
"""
input Wallet_pk_columns_input {
  id: String!
}

"""
select columns of table "Wallet"
"""
enum Wallet_select_column {
  """
  column name
  """
  address

  """
  column name
  """
  balanceUsd

  """
  column name
  """
  createdAt

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  network

  """
  column name
  """
  updatedAt
}

"""
input type for updating data in table "Wallet"
"""
input Wallet_set_input {
  address: String
  balanceUsd: float8
  createdAt: timestamp
  id: String
  name: String
  network: String
  updatedAt: timestamp
}

"""
aggregate stddev on columns
"""
type Wallet_stddev_fields {
  balanceUsd: Float
}

"""
aggregate stddev_pop on columns
"""
type Wallet_stddev_pop_fields {
  balanceUsd: Float
}

"""
aggregate stddev_samp on columns
"""
type Wallet_stddev_samp_fields {
  balanceUsd: Float
}

"""
Streaming cursor of the table "Wallet"
"""
input Wallet_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Wallet_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Wallet_stream_cursor_value_input {
  address: String
  balanceUsd: float8
  createdAt: timestamp
  id: String
  name: String
  network: String
  updatedAt: timestamp
}

"""
aggregate sum on columns
"""
type Wallet_sum_fields {
  balanceUsd: float8
}

"""
update columns of table "Wallet"
"""
enum Wallet_update_column {
  """
  column name
  """
  address

  """
  column name
  """
  balanceUsd

  """
  column name
  """
  createdAt

  """
  column name
  """
  id

  """
  column name
  """
  name

  """
  column name
  """
  network

  """
  column name
  """
  updatedAt
}

input Wallet_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: Wallet_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: Wallet_set_input
  where: Wallet_bool_exp!
}

"""
aggregate var_pop on columns
"""
type Wallet_var_pop_fields {
  balanceUsd: Float
}

"""
aggregate var_samp on columns
"""
type Wallet_var_samp_fields {
  balanceUsd: Float
}

"""
aggregate variance on columns
"""
type Wallet_variance_fields {
  balanceUsd: Float
}

"""
columns and relationships of "accounts"
"""
type accounts {
  access_token: String
  expires_at: Int
  id: String!
  id_token: String
  provider: String!
  providerAccountId: String!
  refresh_expires_in: Int
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String!
  userId: String!
}

"""
aggregated selection of "accounts"
"""
type accounts_aggregate {
  aggregate: accounts_aggregate_fields
  nodes: [accounts!]!
}

"""
aggregate fields of "accounts"
"""
type accounts_aggregate_fields {
  avg: accounts_avg_fields
  count(columns: [accounts_select_column!], distinct: Boolean): Int!
  max: accounts_max_fields
  min: accounts_min_fields
  stddev: accounts_stddev_fields
  stddev_pop: accounts_stddev_pop_fields
  stddev_samp: accounts_stddev_samp_fields
  sum: accounts_sum_fields
  var_pop: accounts_var_pop_fields
  var_samp: accounts_var_samp_fields
  variance: accounts_variance_fields
}

"""
order by aggregate values of table "accounts"
"""
input accounts_aggregate_order_by {
  avg: accounts_avg_order_by
  count: order_by
  max: accounts_max_order_by
  min: accounts_min_order_by
  stddev: accounts_stddev_order_by
  stddev_pop: accounts_stddev_pop_order_by
  stddev_samp: accounts_stddev_samp_order_by
  sum: accounts_sum_order_by
  var_pop: accounts_var_pop_order_by
  var_samp: accounts_var_samp_order_by
  variance: accounts_variance_order_by
}

"""
input type for inserting array relation for remote table "accounts"
"""
input accounts_arr_rel_insert_input {
  data: [accounts_insert_input!]!

  """
  upsert condition
  """
  on_conflict: accounts_on_conflict
}

"""
aggregate avg on columns
"""
type accounts_avg_fields {
  expires_at: Float
  refresh_expires_in: Float
}

"""
order by avg() on columns of table "accounts"
"""
input accounts_avg_order_by {
  expires_at: order_by
  refresh_expires_in: order_by
}

"""
Boolean expression to filter rows from the table "accounts". All fields are combined with a logical 'AND'.
"""
input accounts_bool_exp {
  _and: [accounts_bool_exp!]
  _not: accounts_bool_exp
  _or: [accounts_bool_exp!]
  access_token: String_comparison_exp
  expires_at: Int_comparison_exp
  id: String_comparison_exp
  id_token: String_comparison_exp
  provider: String_comparison_exp
  providerAccountId: String_comparison_exp
  refresh_expires_in: Int_comparison_exp
  refresh_token: String_comparison_exp
  scope: String_comparison_exp
  session_state: String_comparison_exp
  token_type: String_comparison_exp
  type: String_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "accounts"
"""
enum accounts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  accounts_pkey
}

"""
input type for incrementing numeric columns in table "accounts"
"""
input accounts_inc_input {
  expires_at: Int
  refresh_expires_in: Int
}

"""
input type for inserting data into table "accounts"
"""
input accounts_insert_input {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String
  providerAccountId: String
  refresh_expires_in: Int
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: String
}

"""
aggregate max on columns
"""
type accounts_max_fields {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String
  providerAccountId: String
  refresh_expires_in: Int
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: String
}

"""
order by max() on columns of table "accounts"
"""
input accounts_max_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  provider: order_by
  providerAccountId: order_by
  refresh_expires_in: order_by
  refresh_token: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  userId: order_by
}

"""
aggregate min on columns
"""
type accounts_min_fields {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String
  providerAccountId: String
  refresh_expires_in: Int
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: String
}

"""
order by min() on columns of table "accounts"
"""
input accounts_min_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  provider: order_by
  providerAccountId: order_by
  refresh_expires_in: order_by
  refresh_token: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  userId: order_by
}

"""
response of any mutation on the table "accounts"
"""
type accounts_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [accounts!]!
}

"""
on_conflict condition type for table "accounts"
"""
input accounts_on_conflict {
  constraint: accounts_constraint!
  update_columns: [accounts_update_column!]! = []
  where: accounts_bool_exp
}

"""
Ordering options when selecting data from "accounts".
"""
input accounts_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  provider: order_by
  providerAccountId: order_by
  refresh_expires_in: order_by
  refresh_token: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  userId: order_by
}

"""
primary key columns input for table: accounts
"""
input accounts_pk_columns_input {
  id: String!
}

"""
select columns of table "accounts"
"""
enum accounts_select_column {
  """
  column name
  """
  access_token

  """
  column name
  """
  expires_at

  """
  column name
  """
  id

  """
  column name
  """
  id_token

  """
  column name
  """
  provider

  """
  column name
  """
  providerAccountId

  """
  column name
  """
  refresh_expires_in

  """
  column name
  """
  refresh_token

  """
  column name
  """
  scope

  """
  column name
  """
  session_state

  """
  column name
  """
  token_type

  """
  column name
  """
  type

  """
  column name
  """
  userId
}

"""
input type for updating data in table "accounts"
"""
input accounts_set_input {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String
  providerAccountId: String
  refresh_expires_in: Int
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: String
}

"""
aggregate stddev on columns
"""
type accounts_stddev_fields {
  expires_at: Float
  refresh_expires_in: Float
}

"""
order by stddev() on columns of table "accounts"
"""
input accounts_stddev_order_by {
  expires_at: order_by
  refresh_expires_in: order_by
}

"""
aggregate stddev_pop on columns
"""
type accounts_stddev_pop_fields {
  expires_at: Float
  refresh_expires_in: Float
}

"""
order by stddev_pop() on columns of table "accounts"
"""
input accounts_stddev_pop_order_by {
  expires_at: order_by
  refresh_expires_in: order_by
}

"""
aggregate stddev_samp on columns
"""
type accounts_stddev_samp_fields {
  expires_at: Float
  refresh_expires_in: Float
}

"""
order by stddev_samp() on columns of table "accounts"
"""
input accounts_stddev_samp_order_by {
  expires_at: order_by
  refresh_expires_in: order_by
}

"""
Streaming cursor of the table "accounts"
"""
input accounts_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: accounts_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input accounts_stream_cursor_value_input {
  access_token: String
  expires_at: Int
  id: String
  id_token: String
  provider: String
  providerAccountId: String
  refresh_expires_in: Int
  refresh_token: String
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: String
}

"""
aggregate sum on columns
"""
type accounts_sum_fields {
  expires_at: Int
  refresh_expires_in: Int
}

"""
order by sum() on columns of table "accounts"
"""
input accounts_sum_order_by {
  expires_at: order_by
  refresh_expires_in: order_by
}

"""
update columns of table "accounts"
"""
enum accounts_update_column {
  """
  column name
  """
  access_token

  """
  column name
  """
  expires_at

  """
  column name
  """
  id

  """
  column name
  """
  id_token

  """
  column name
  """
  provider

  """
  column name
  """
  providerAccountId

  """
  column name
  """
  refresh_expires_in

  """
  column name
  """
  refresh_token

  """
  column name
  """
  scope

  """
  column name
  """
  session_state

  """
  column name
  """
  token_type

  """
  column name
  """
  type

  """
  column name
  """
  userId
}

input accounts_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: accounts_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: accounts_set_input
  where: accounts_bool_exp!
}

"""
aggregate var_pop on columns
"""
type accounts_var_pop_fields {
  expires_at: Float
  refresh_expires_in: Float
}

"""
order by var_pop() on columns of table "accounts"
"""
input accounts_var_pop_order_by {
  expires_at: order_by
  refresh_expires_in: order_by
}

"""
aggregate var_samp on columns
"""
type accounts_var_samp_fields {
  expires_at: Float
  refresh_expires_in: Float
}

"""
order by var_samp() on columns of table "accounts"
"""
input accounts_var_samp_order_by {
  expires_at: order_by
  refresh_expires_in: order_by
}

"""
aggregate variance on columns
"""
type accounts_variance_fields {
  expires_at: Float
  refresh_expires_in: Float
}

"""
order by variance() on columns of table "accounts"
"""
input accounts_variance_order_by {
  expires_at: order_by
  refresh_expires_in: order_by
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
  """
  ascending ordering of the cursor
  """
  ASC

  """
  descending ordering of the cursor
  """
  DESC
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"""
mutation root
"""
type mutation_root {
  """
  delete data from the table: "Transaction"
  """
  delete_Transaction(
    """
    filter the rows which have to be deleted
    """
    where: Transaction_bool_exp!
  ): Transaction_mutation_response

  """
  delete single row from the table: "Transaction"
  """
  delete_Transaction_by_pk(id: String!): Transaction

  """
  delete data from the table: "Wallet"
  """
  delete_Wallet(
    """
    filter the rows which have to be deleted
    """
    where: Wallet_bool_exp!
  ): Wallet_mutation_response

  """
  delete single row from the table: "Wallet"
  """
  delete_Wallet_by_pk(id: String!): Wallet

  """
  delete data from the table: "accounts"
  """
  delete_accounts(
    """
    filter the rows which have to be deleted
    """
    where: accounts_bool_exp!
  ): accounts_mutation_response

  """
  delete single row from the table: "accounts"
  """
  delete_accounts_by_pk(id: String!): accounts

  """
  delete data from the table: "passwords"
  """
  delete_passwords(
    """
    filter the rows which have to be deleted
    """
    where: passwords_bool_exp!
  ): passwords_mutation_response

  """
  delete single row from the table: "passwords"
  """
  delete_passwords_by_pk(hash: String!): passwords

  """
  delete data from the table: "sessions"
  """
  delete_sessions(
    """
    filter the rows which have to be deleted
    """
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  delete single row from the table: "sessions"
  """
  delete_sessions_by_pk(id: String!): sessions

  """
  delete data from the table: "users"
  """
  delete_users(
    """
    filter the rows which have to be deleted
    """
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: String!): users

  """
  delete data from the table: "verificationTokens"
  """
  delete_verificationTokens(
    """
    filter the rows which have to be deleted
    """
    where: verificationTokens_bool_exp!
  ): verificationTokens_mutation_response

  """
  insert data into the table: "Transaction"
  """
  insert_Transaction(
    """
    the rows to be inserted
    """
    objects: [Transaction_insert_input!]!

    """
    upsert condition
    """
    on_conflict: Transaction_on_conflict
  ): Transaction_mutation_response

  """
  insert a single row into the table: "Transaction"
  """
  insert_Transaction_one(
    """
    the row to be inserted
    """
    object: Transaction_insert_input!

    """
    upsert condition
    """
    on_conflict: Transaction_on_conflict
  ): Transaction

  """
  insert data into the table: "Wallet"
  """
  insert_Wallet(
    """
    the rows to be inserted
    """
    objects: [Wallet_insert_input!]!

    """
    upsert condition
    """
    on_conflict: Wallet_on_conflict
  ): Wallet_mutation_response

  """
  insert a single row into the table: "Wallet"
  """
  insert_Wallet_one(
    """
    the row to be inserted
    """
    object: Wallet_insert_input!

    """
    upsert condition
    """
    on_conflict: Wallet_on_conflict
  ): Wallet

  """
  insert data into the table: "accounts"
  """
  insert_accounts(
    """
    the rows to be inserted
    """
    objects: [accounts_insert_input!]!

    """
    upsert condition
    """
    on_conflict: accounts_on_conflict
  ): accounts_mutation_response

  """
  insert a single row into the table: "accounts"
  """
  insert_accounts_one(
    """
    the row to be inserted
    """
    object: accounts_insert_input!

    """
    upsert condition
    """
    on_conflict: accounts_on_conflict
  ): accounts

  """
  insert data into the table: "passwords"
  """
  insert_passwords(
    """
    the rows to be inserted
    """
    objects: [passwords_insert_input!]!

    """
    upsert condition
    """
    on_conflict: passwords_on_conflict
  ): passwords_mutation_response

  """
  insert a single row into the table: "passwords"
  """
  insert_passwords_one(
    """
    the row to be inserted
    """
    object: passwords_insert_input!

    """
    upsert condition
    """
    on_conflict: passwords_on_conflict
  ): passwords

  """
  insert data into the table: "sessions"
  """
  insert_sessions(
    """
    the rows to be inserted
    """
    objects: [sessions_insert_input!]!

    """
    upsert condition
    """
    on_conflict: sessions_on_conflict
  ): sessions_mutation_response

  """
  insert a single row into the table: "sessions"
  """
  insert_sessions_one(
    """
    the row to be inserted
    """
    object: sessions_insert_input!

    """
    upsert condition
    """
    on_conflict: sessions_on_conflict
  ): sessions

  """
  insert data into the table: "users"
  """
  insert_users(
    """
    the rows to be inserted
    """
    objects: [users_insert_input!]!

    """
    upsert condition
    """
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """
    the row to be inserted
    """
    object: users_insert_input!

    """
    upsert condition
    """
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "verificationTokens"
  """
  insert_verificationTokens(
    """
    the rows to be inserted
    """
    objects: [verificationTokens_insert_input!]!
  ): verificationTokens_mutation_response

  """
  insert a single row into the table: "verificationTokens"
  """
  insert_verificationTokens_one(
    """
    the row to be inserted
    """
    object: verificationTokens_insert_input!
  ): verificationTokens

  """
  update data of the table: "Transaction"
  """
  update_Transaction(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: Transaction_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: Transaction_set_input

    """
    filter the rows which have to be updated
    """
    where: Transaction_bool_exp!
  ): Transaction_mutation_response

  """
  update single row of the table: "Transaction"
  """
  update_Transaction_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: Transaction_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: Transaction_set_input
    pk_columns: Transaction_pk_columns_input!
  ): Transaction

  """
  update multiples rows of table: "Transaction"
  """
  update_Transaction_many(
    """
    updates to execute, in order
    """
    updates: [Transaction_updates!]!
  ): [Transaction_mutation_response]

  """
  update data of the table: "Wallet"
  """
  update_Wallet(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: Wallet_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: Wallet_set_input

    """
    filter the rows which have to be updated
    """
    where: Wallet_bool_exp!
  ): Wallet_mutation_response

  """
  update single row of the table: "Wallet"
  """
  update_Wallet_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: Wallet_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: Wallet_set_input
    pk_columns: Wallet_pk_columns_input!
  ): Wallet

  """
  update multiples rows of table: "Wallet"
  """
  update_Wallet_many(
    """
    updates to execute, in order
    """
    updates: [Wallet_updates!]!
  ): [Wallet_mutation_response]

  """
  update data of the table: "accounts"
  """
  update_accounts(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: accounts_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: accounts_set_input

    """
    filter the rows which have to be updated
    """
    where: accounts_bool_exp!
  ): accounts_mutation_response

  """
  update single row of the table: "accounts"
  """
  update_accounts_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: accounts_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: accounts_set_input
    pk_columns: accounts_pk_columns_input!
  ): accounts

  """
  update multiples rows of table: "accounts"
  """
  update_accounts_many(
    """
    updates to execute, in order
    """
    updates: [accounts_updates!]!
  ): [accounts_mutation_response]

  """
  update data of the table: "passwords"
  """
  update_passwords(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: passwords_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: passwords_set_input

    """
    filter the rows which have to be updated
    """
    where: passwords_bool_exp!
  ): passwords_mutation_response

  """
  update single row of the table: "passwords"
  """
  update_passwords_by_pk(
    """
    increments the numeric columns with given value of the filtered values
    """
    _inc: passwords_inc_input

    """
    sets the columns of the filtered rows to the given values
    """
    _set: passwords_set_input
    pk_columns: passwords_pk_columns_input!
  ): passwords

  """
  update multiples rows of table: "passwords"
  """
  update_passwords_many(
    """
    updates to execute, in order
    """
    updates: [passwords_updates!]!
  ): [passwords_mutation_response]

  """
  update data of the table: "sessions"
  """
  update_sessions(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: sessions_set_input

    """
    filter the rows which have to be updated
    """
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  update single row of the table: "sessions"
  """
  update_sessions_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: sessions_set_input
    pk_columns: sessions_pk_columns_input!
  ): sessions

  """
  update multiples rows of table: "sessions"
  """
  update_sessions_many(
    """
    updates to execute, in order
    """
    updates: [sessions_updates!]!
  ): [sessions_mutation_response]

  """
  update data of the table: "users"
  """
  update_users(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: users_set_input

    """
    filter the rows which have to be updated
    """
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update multiples rows of table: "users"
  """
  update_users_many(
    """
    updates to execute, in order
    """
    updates: [users_updates!]!
  ): [users_mutation_response]

  """
  update data of the table: "verificationTokens"
  """
  update_verificationTokens(
    """
    sets the columns of the filtered rows to the given values
    """
    _set: verificationTokens_set_input

    """
    filter the rows which have to be updated
    """
    where: verificationTokens_bool_exp!
  ): verificationTokens_mutation_response

  """
  update multiples rows of table: "verificationTokens"
  """
  update_verificationTokens_many(
    """
    updates to execute, in order
    """
    updates: [verificationTokens_updates!]!
  ): [verificationTokens_mutation_response]
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

"""
columns and relationships of "passwords"
"""
type passwords {
  attempts: Int!
  hash: String!
  iterations: Int!
  salt: String!
  userId: String!
}

"""
aggregated selection of "passwords"
"""
type passwords_aggregate {
  aggregate: passwords_aggregate_fields
  nodes: [passwords!]!
}

"""
aggregate fields of "passwords"
"""
type passwords_aggregate_fields {
  avg: passwords_avg_fields
  count(columns: [passwords_select_column!], distinct: Boolean): Int!
  max: passwords_max_fields
  min: passwords_min_fields
  stddev: passwords_stddev_fields
  stddev_pop: passwords_stddev_pop_fields
  stddev_samp: passwords_stddev_samp_fields
  sum: passwords_sum_fields
  var_pop: passwords_var_pop_fields
  var_samp: passwords_var_samp_fields
  variance: passwords_variance_fields
}

"""
order by aggregate values of table "passwords"
"""
input passwords_aggregate_order_by {
  avg: passwords_avg_order_by
  count: order_by
  max: passwords_max_order_by
  min: passwords_min_order_by
  stddev: passwords_stddev_order_by
  stddev_pop: passwords_stddev_pop_order_by
  stddev_samp: passwords_stddev_samp_order_by
  sum: passwords_sum_order_by
  var_pop: passwords_var_pop_order_by
  var_samp: passwords_var_samp_order_by
  variance: passwords_variance_order_by
}

"""
input type for inserting array relation for remote table "passwords"
"""
input passwords_arr_rel_insert_input {
  data: [passwords_insert_input!]!

  """
  upsert condition
  """
  on_conflict: passwords_on_conflict
}

"""
aggregate avg on columns
"""
type passwords_avg_fields {
  attempts: Float
  iterations: Float
}

"""
order by avg() on columns of table "passwords"
"""
input passwords_avg_order_by {
  attempts: order_by
  iterations: order_by
}

"""
Boolean expression to filter rows from the table "passwords". All fields are combined with a logical 'AND'.
"""
input passwords_bool_exp {
  _and: [passwords_bool_exp!]
  _not: passwords_bool_exp
  _or: [passwords_bool_exp!]
  attempts: Int_comparison_exp
  hash: String_comparison_exp
  iterations: Int_comparison_exp
  salt: String_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "passwords"
"""
enum passwords_constraint {
  """
  unique or primary key constraint on columns "hash"
  """
  passwords_pkey

  """
  unique or primary key constraint on columns "salt"
  """
  passwords_salt_key
}

"""
input type for incrementing numeric columns in table "passwords"
"""
input passwords_inc_input {
  attempts: Int
  iterations: Int
}

"""
input type for inserting data into table "passwords"
"""
input passwords_insert_input {
  attempts: Int
  hash: String
  iterations: Int
  salt: String
  userId: String
}

"""
aggregate max on columns
"""
type passwords_max_fields {
  attempts: Int
  hash: String
  iterations: Int
  salt: String
  userId: String
}

"""
order by max() on columns of table "passwords"
"""
input passwords_max_order_by {
  attempts: order_by
  hash: order_by
  iterations: order_by
  salt: order_by
  userId: order_by
}

"""
aggregate min on columns
"""
type passwords_min_fields {
  attempts: Int
  hash: String
  iterations: Int
  salt: String
  userId: String
}

"""
order by min() on columns of table "passwords"
"""
input passwords_min_order_by {
  attempts: order_by
  hash: order_by
  iterations: order_by
  salt: order_by
  userId: order_by
}

"""
response of any mutation on the table "passwords"
"""
type passwords_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [passwords!]!
}

"""
on_conflict condition type for table "passwords"
"""
input passwords_on_conflict {
  constraint: passwords_constraint!
  update_columns: [passwords_update_column!]! = []
  where: passwords_bool_exp
}

"""
Ordering options when selecting data from "passwords".
"""
input passwords_order_by {
  attempts: order_by
  hash: order_by
  iterations: order_by
  salt: order_by
  userId: order_by
}

"""
primary key columns input for table: passwords
"""
input passwords_pk_columns_input {
  hash: String!
}

"""
select columns of table "passwords"
"""
enum passwords_select_column {
  """
  column name
  """
  attempts

  """
  column name
  """
  hash

  """
  column name
  """
  iterations

  """
  column name
  """
  salt

  """
  column name
  """
  userId
}

"""
input type for updating data in table "passwords"
"""
input passwords_set_input {
  attempts: Int
  hash: String
  iterations: Int
  salt: String
  userId: String
}

"""
aggregate stddev on columns
"""
type passwords_stddev_fields {
  attempts: Float
  iterations: Float
}

"""
order by stddev() on columns of table "passwords"
"""
input passwords_stddev_order_by {
  attempts: order_by
  iterations: order_by
}

"""
aggregate stddev_pop on columns
"""
type passwords_stddev_pop_fields {
  attempts: Float
  iterations: Float
}

"""
order by stddev_pop() on columns of table "passwords"
"""
input passwords_stddev_pop_order_by {
  attempts: order_by
  iterations: order_by
}

"""
aggregate stddev_samp on columns
"""
type passwords_stddev_samp_fields {
  attempts: Float
  iterations: Float
}

"""
order by stddev_samp() on columns of table "passwords"
"""
input passwords_stddev_samp_order_by {
  attempts: order_by
  iterations: order_by
}

"""
Streaming cursor of the table "passwords"
"""
input passwords_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: passwords_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input passwords_stream_cursor_value_input {
  attempts: Int
  hash: String
  iterations: Int
  salt: String
  userId: String
}

"""
aggregate sum on columns
"""
type passwords_sum_fields {
  attempts: Int
  iterations: Int
}

"""
order by sum() on columns of table "passwords"
"""
input passwords_sum_order_by {
  attempts: order_by
  iterations: order_by
}

"""
update columns of table "passwords"
"""
enum passwords_update_column {
  """
  column name
  """
  attempts

  """
  column name
  """
  hash

  """
  column name
  """
  iterations

  """
  column name
  """
  salt

  """
  column name
  """
  userId
}

input passwords_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: passwords_inc_input

  """
  sets the columns of the filtered rows to the given values
  """
  _set: passwords_set_input
  where: passwords_bool_exp!
}

"""
aggregate var_pop on columns
"""
type passwords_var_pop_fields {
  attempts: Float
  iterations: Float
}

"""
order by var_pop() on columns of table "passwords"
"""
input passwords_var_pop_order_by {
  attempts: order_by
  iterations: order_by
}

"""
aggregate var_samp on columns
"""
type passwords_var_samp_fields {
  attempts: Float
  iterations: Float
}

"""
order by var_samp() on columns of table "passwords"
"""
input passwords_var_samp_order_by {
  attempts: order_by
  iterations: order_by
}

"""
aggregate variance on columns
"""
type passwords_variance_fields {
  attempts: Float
  iterations: Float
}

"""
order by variance() on columns of table "passwords"
"""
input passwords_variance_order_by {
  attempts: order_by
  iterations: order_by
}

type query_root {
  """
  fetch data from the table: "Transaction"
  """
  Transaction(
    """
    distinct select on columns
    """
    distinct_on: [Transaction_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Transaction_order_by!]

    """
    filter the rows returned
    """
    where: Transaction_bool_exp
  ): [Transaction!]!

  """
  fetch aggregated fields from the table: "Transaction"
  """
  Transaction_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [Transaction_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Transaction_order_by!]

    """
    filter the rows returned
    """
    where: Transaction_bool_exp
  ): Transaction_aggregate!

  """
  fetch data from the table: "Transaction" using primary key columns
  """
  Transaction_by_pk(id: String!): Transaction

  """
  fetch data from the table: "Wallet"
  """
  Wallet(
    """
    distinct select on columns
    """
    distinct_on: [Wallet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Wallet_order_by!]

    """
    filter the rows returned
    """
    where: Wallet_bool_exp
  ): [Wallet!]!

  """
  fetch aggregated fields from the table: "Wallet"
  """
  Wallet_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [Wallet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Wallet_order_by!]

    """
    filter the rows returned
    """
    where: Wallet_bool_exp
  ): Wallet_aggregate!

  """
  fetch data from the table: "Wallet" using primary key columns
  """
  Wallet_by_pk(id: String!): Wallet

  """
  An array relationship
  """
  accounts(
    """
    distinct select on columns
    """
    distinct_on: [accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [accounts_order_by!]

    """
    filter the rows returned
    """
    where: accounts_bool_exp
  ): [accounts!]!

  """
  An aggregate relationship
  """
  accounts_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [accounts_order_by!]

    """
    filter the rows returned
    """
    where: accounts_bool_exp
  ): accounts_aggregate!

  """
  fetch data from the table: "accounts" using primary key columns
  """
  accounts_by_pk(id: String!): accounts

  """
  Get balances of token for an address in given network
  """
  balancesEIP377(address: String!, network: String!): [BalanceTokenData]

  """
  An array relationship
  """
  passwords(
    """
    distinct select on columns
    """
    distinct_on: [passwords_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [passwords_order_by!]

    """
    filter the rows returned
    """
    where: passwords_bool_exp
  ): [passwords!]!

  """
  An aggregate relationship
  """
  passwords_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [passwords_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [passwords_order_by!]

    """
    filter the rows returned
    """
    where: passwords_bool_exp
  ): passwords_aggregate!

  """
  fetch data from the table: "passwords" using primary key columns
  """
  passwords_by_pk(hash: String!): passwords

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  An aggregate relationship
  """
  sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): sessions_aggregate!

  """
  fetch data from the table: "sessions" using primary key columns
  """
  sessions_by_pk(id: String!): sessions

  """
  fetch data from the table: "users"
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  users_by_pk(id: String!): users

  """
  fetch data from the table: "verificationTokens"
  """
  verificationTokens(
    """
    distinct select on columns
    """
    distinct_on: [verificationTokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [verificationTokens_order_by!]

    """
    filter the rows returned
    """
    where: verificationTokens_bool_exp
  ): [verificationTokens!]!

  """
  fetch aggregated fields from the table: "verificationTokens"
  """
  verificationTokens_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [verificationTokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [verificationTokens_order_by!]

    """
    filter the rows returned
    """
    where: verificationTokens_bool_exp
  ): verificationTokens_aggregate!
}

"""
columns and relationships of "sessions"
"""
type sessions {
  expires: timestamp
  id: String!
  sessionToken: String!

  """
  An object relationship
  """
  user: users
  userId: String!
}

"""
aggregated selection of "sessions"
"""
type sessions_aggregate {
  aggregate: sessions_aggregate_fields
  nodes: [sessions!]!
}

"""
aggregate fields of "sessions"
"""
type sessions_aggregate_fields {
  count(columns: [sessions_select_column!], distinct: Boolean): Int!
  max: sessions_max_fields
  min: sessions_min_fields
}

"""
order by aggregate values of table "sessions"
"""
input sessions_aggregate_order_by {
  count: order_by
  max: sessions_max_order_by
  min: sessions_min_order_by
}

"""
input type for inserting array relation for remote table "sessions"
"""
input sessions_arr_rel_insert_input {
  data: [sessions_insert_input!]!

  """
  upsert condition
  """
  on_conflict: sessions_on_conflict
}

"""
Boolean expression to filter rows from the table "sessions". All fields are combined with a logical 'AND'.
"""
input sessions_bool_exp {
  _and: [sessions_bool_exp!]
  _not: sessions_bool_exp
  _or: [sessions_bool_exp!]
  expires: timestamp_comparison_exp
  id: String_comparison_exp
  sessionToken: String_comparison_exp
  user: users_bool_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "sessions"
"""
enum sessions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sessions_pkey
}

"""
input type for inserting data into table "sessions"
"""
input sessions_insert_input {
  expires: timestamp
  id: String
  sessionToken: String
  user: users_obj_rel_insert_input
  userId: String
}

"""
aggregate max on columns
"""
type sessions_max_fields {
  expires: timestamp
  id: String
  sessionToken: String
  userId: String
}

"""
order by max() on columns of table "sessions"
"""
input sessions_max_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  userId: order_by
}

"""
aggregate min on columns
"""
type sessions_min_fields {
  expires: timestamp
  id: String
  sessionToken: String
  userId: String
}

"""
order by min() on columns of table "sessions"
"""
input sessions_min_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  userId: order_by
}

"""
response of any mutation on the table "sessions"
"""
type sessions_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [sessions!]!
}

"""
on_conflict condition type for table "sessions"
"""
input sessions_on_conflict {
  constraint: sessions_constraint!
  update_columns: [sessions_update_column!]! = []
  where: sessions_bool_exp
}

"""
Ordering options when selecting data from "sessions".
"""
input sessions_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  user: users_order_by
  userId: order_by
}

"""
primary key columns input for table: sessions
"""
input sessions_pk_columns_input {
  id: String!
}

"""
select columns of table "sessions"
"""
enum sessions_select_column {
  """
  column name
  """
  expires

  """
  column name
  """
  id

  """
  column name
  """
  sessionToken

  """
  column name
  """
  userId
}

"""
input type for updating data in table "sessions"
"""
input sessions_set_input {
  expires: timestamp
  id: String
  sessionToken: String
  userId: String
}

"""
Streaming cursor of the table "sessions"
"""
input sessions_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: sessions_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input sessions_stream_cursor_value_input {
  expires: timestamp
  id: String
  sessionToken: String
  userId: String
}

"""
update columns of table "sessions"
"""
enum sessions_update_column {
  """
  column name
  """
  expires

  """
  column name
  """
  id

  """
  column name
  """
  sessionToken

  """
  column name
  """
  userId
}

input sessions_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: sessions_set_input
  where: sessions_bool_exp!
}

type subscription_root {
  """
  fetch data from the table: "Transaction"
  """
  Transaction(
    """
    distinct select on columns
    """
    distinct_on: [Transaction_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Transaction_order_by!]

    """
    filter the rows returned
    """
    where: Transaction_bool_exp
  ): [Transaction!]!

  """
  fetch aggregated fields from the table: "Transaction"
  """
  Transaction_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [Transaction_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Transaction_order_by!]

    """
    filter the rows returned
    """
    where: Transaction_bool_exp
  ): Transaction_aggregate!

  """
  fetch data from the table: "Transaction" using primary key columns
  """
  Transaction_by_pk(id: String!): Transaction

  """
  fetch data from the table in a streaming manner : "Transaction"
  """
  Transaction_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [Transaction_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: Transaction_bool_exp
  ): [Transaction!]!

  """
  fetch data from the table: "Wallet"
  """
  Wallet(
    """
    distinct select on columns
    """
    distinct_on: [Wallet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Wallet_order_by!]

    """
    filter the rows returned
    """
    where: Wallet_bool_exp
  ): [Wallet!]!

  """
  fetch aggregated fields from the table: "Wallet"
  """
  Wallet_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [Wallet_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Wallet_order_by!]

    """
    filter the rows returned
    """
    where: Wallet_bool_exp
  ): Wallet_aggregate!

  """
  fetch data from the table: "Wallet" using primary key columns
  """
  Wallet_by_pk(id: String!): Wallet

  """
  fetch data from the table in a streaming manner : "Wallet"
  """
  Wallet_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [Wallet_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: Wallet_bool_exp
  ): [Wallet!]!

  """
  An array relationship
  """
  accounts(
    """
    distinct select on columns
    """
    distinct_on: [accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [accounts_order_by!]

    """
    filter the rows returned
    """
    where: accounts_bool_exp
  ): [accounts!]!

  """
  An aggregate relationship
  """
  accounts_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [accounts_order_by!]

    """
    filter the rows returned
    """
    where: accounts_bool_exp
  ): accounts_aggregate!

  """
  fetch data from the table: "accounts" using primary key columns
  """
  accounts_by_pk(id: String!): accounts

  """
  fetch data from the table in a streaming manner : "accounts"
  """
  accounts_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [accounts_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: accounts_bool_exp
  ): [accounts!]!

  """
  An array relationship
  """
  passwords(
    """
    distinct select on columns
    """
    distinct_on: [passwords_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [passwords_order_by!]

    """
    filter the rows returned
    """
    where: passwords_bool_exp
  ): [passwords!]!

  """
  An aggregate relationship
  """
  passwords_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [passwords_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [passwords_order_by!]

    """
    filter the rows returned
    """
    where: passwords_bool_exp
  ): passwords_aggregate!

  """
  fetch data from the table: "passwords" using primary key columns
  """
  passwords_by_pk(hash: String!): passwords

  """
  fetch data from the table in a streaming manner : "passwords"
  """
  passwords_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [passwords_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: passwords_bool_exp
  ): [passwords!]!

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  An aggregate relationship
  """
  sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): sessions_aggregate!

  """
  fetch data from the table: "sessions" using primary key columns
  """
  sessions_by_pk(id: String!): sessions

  """
  fetch data from the table in a streaming manner : "sessions"
  """
  sessions_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [sessions_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  fetch data from the table: "users"
  """
  users(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [users_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [users_order_by!]

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table: "users" using primary key columns
  """
  users_by_pk(id: String!): users

  """
  fetch data from the table in a streaming manner : "users"
  """
  users_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [users_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: users_bool_exp
  ): [users!]!

  """
  fetch data from the table: "verificationTokens"
  """
  verificationTokens(
    """
    distinct select on columns
    """
    distinct_on: [verificationTokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [verificationTokens_order_by!]

    """
    filter the rows returned
    """
    where: verificationTokens_bool_exp
  ): [verificationTokens!]!

  """
  fetch aggregated fields from the table: "verificationTokens"
  """
  verificationTokens_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [verificationTokens_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [verificationTokens_order_by!]

    """
    filter the rows returned
    """
    where: verificationTokens_bool_exp
  ): verificationTokens_aggregate!

  """
  fetch data from the table in a streaming manner : "verificationTokens"
  """
  verificationTokens_stream(
    """
    maximum number of rows returned in a single batch
    """
    batch_size: Int!

    """
    cursor to stream the results returned by the query
    """
    cursor: [verificationTokens_stream_cursor_input]!

    """
    filter the rows returned
    """
    where: verificationTokens_bool_exp
  ): [verificationTokens!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"""
columns and relationships of "users"
"""
type users {
  """
  An array relationship
  """
  accounts(
    """
    distinct select on columns
    """
    distinct_on: [accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [accounts_order_by!]

    """
    filter the rows returned
    """
    where: accounts_bool_exp
  ): [accounts!]!

  """
  An aggregate relationship
  """
  accounts_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [accounts_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [accounts_order_by!]

    """
    filter the rows returned
    """
    where: accounts_bool_exp
  ): accounts_aggregate!
  blocked: Boolean!
  email: String
  emailVerified: timestamp
  firstName: String
  id: String!
  image: String
  lastName: String
  name: String

  """
  An array relationship
  """
  passwords(
    """
    distinct select on columns
    """
    distinct_on: [passwords_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [passwords_order_by!]

    """
    filter the rows returned
    """
    where: passwords_bool_exp
  ): [passwords!]!

  """
  An aggregate relationship
  """
  passwords_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [passwords_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [passwords_order_by!]

    """
    filter the rows returned
    """
    where: passwords_bool_exp
  ): passwords_aggregate!

  """
  An array relationship
  """
  sessions(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): [sessions!]!

  """
  An aggregate relationship
  """
  sessions_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [sessions_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [sessions_order_by!]

    """
    filter the rows returned
    """
    where: sessions_bool_exp
  ): sessions_aggregate!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  accounts: accounts_bool_exp
  blocked: Boolean_comparison_exp
  email: String_comparison_exp
  emailVerified: timestamp_comparison_exp
  firstName: String_comparison_exp
  id: String_comparison_exp
  image: String_comparison_exp
  lastName: String_comparison_exp
  name: String_comparison_exp
  passwords: passwords_bool_exp
  sessions: sessions_bool_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  accounts: accounts_arr_rel_insert_input
  blocked: Boolean
  email: String
  emailVerified: timestamp
  firstName: String
  id: String
  image: String
  lastName: String
  name: String
  passwords: passwords_arr_rel_insert_input
  sessions: sessions_arr_rel_insert_input
}

"""
aggregate max on columns
"""
type users_max_fields {
  email: String
  emailVerified: timestamp
  firstName: String
  id: String
  image: String
  lastName: String
  name: String
}

"""
aggregate min on columns
"""
type users_min_fields {
  email: String
  emailVerified: timestamp
  firstName: String
  id: String
  image: String
  lastName: String
  name: String
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """
  upsert condition
  """
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""
Ordering options when selecting data from "users".
"""
input users_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  blocked: order_by
  email: order_by
  emailVerified: order_by
  firstName: order_by
  id: order_by
  image: order_by
  lastName: order_by
  name: order_by
  passwords_aggregate: passwords_aggregate_order_by
  sessions_aggregate: sessions_aggregate_order_by
}

"""
primary key columns input for table: users
"""
input users_pk_columns_input {
  id: String!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """
  column name
  """
  blocked

  """
  column name
  """
  email

  """
  column name
  """
  emailVerified

  """
  column name
  """
  firstName

  """
  column name
  """
  id

  """
  column name
  """
  image

  """
  column name
  """
  lastName

  """
  column name
  """
  name
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  blocked: Boolean
  email: String
  emailVerified: timestamp
  firstName: String
  id: String
  image: String
  lastName: String
  name: String
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: users_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input users_stream_cursor_value_input {
  blocked: Boolean
  email: String
  emailVerified: timestamp
  firstName: String
  id: String
  image: String
  lastName: String
  name: String
}

"""
update columns of table "users"
"""
enum users_update_column {
  """
  column name
  """
  blocked

  """
  column name
  """
  email

  """
  column name
  """
  emailVerified

  """
  column name
  """
  firstName

  """
  column name
  """
  id

  """
  column name
  """
  image

  """
  column name
  """
  lastName

  """
  column name
  """
  name
}

input users_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: users_set_input
  where: users_bool_exp!
}

"""
columns and relationships of "verificationTokens"
"""
type verificationTokens {
  expires: timestamp!
  identifier: String!
  token: String!
}

"""
aggregated selection of "verificationTokens"
"""
type verificationTokens_aggregate {
  aggregate: verificationTokens_aggregate_fields
  nodes: [verificationTokens!]!
}

"""
aggregate fields of "verificationTokens"
"""
type verificationTokens_aggregate_fields {
  count(columns: [verificationTokens_select_column!], distinct: Boolean): Int!
  max: verificationTokens_max_fields
  min: verificationTokens_min_fields
}

"""
Boolean expression to filter rows from the table "verificationTokens". All fields are combined with a logical 'AND'.
"""
input verificationTokens_bool_exp {
  _and: [verificationTokens_bool_exp!]
  _not: verificationTokens_bool_exp
  _or: [verificationTokens_bool_exp!]
  expires: timestamp_comparison_exp
  identifier: String_comparison_exp
  token: String_comparison_exp
}

"""
input type for inserting data into table "verificationTokens"
"""
input verificationTokens_insert_input {
  expires: timestamp
  identifier: String
  token: String
}

"""
aggregate max on columns
"""
type verificationTokens_max_fields {
  expires: timestamp
  identifier: String
  token: String
}

"""
aggregate min on columns
"""
type verificationTokens_min_fields {
  expires: timestamp
  identifier: String
  token: String
}

"""
response of any mutation on the table "verificationTokens"
"""
type verificationTokens_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!

  """
  data from the rows affected by the mutation
  """
  returning: [verificationTokens!]!
}

"""
Ordering options when selecting data from "verificationTokens".
"""
input verificationTokens_order_by {
  expires: order_by
  identifier: order_by
  token: order_by
}

"""
select columns of table "verificationTokens"
"""
enum verificationTokens_select_column {
  """
  column name
  """
  expires

  """
  column name
  """
  identifier

  """
  column name
  """
  token
}

"""
input type for updating data in table "verificationTokens"
"""
input verificationTokens_set_input {
  expires: timestamp
  identifier: String
  token: String
}

"""
Streaming cursor of the table "verificationTokens"
"""
input verificationTokens_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: verificationTokens_stream_cursor_value_input!

  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input verificationTokens_stream_cursor_value_input {
  expires: timestamp
  identifier: String
  token: String
}

input verificationTokens_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: verificationTokens_set_input
  where: verificationTokens_bool_exp!
}
